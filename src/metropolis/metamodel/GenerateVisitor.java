/* Generate a visitor class and nodes

 Copyright (c) 2003-2006 The Regents of the University of California.
 All rights reserved.

 Permission is hereby granted, without written agreement and without
 license or royalty fees, to use, copy, modify, and distribute this
 software and its documentation for any purpose, provided that the
 above copyright notice and the following two paragraphs appear in all
 copies of this software and that appropriate acknowledgments are made
 to the research of the Metropolis group.

 IN NO EVENT SHALL THE UNIVERSITY OF CALIFORNIA BE LIABLE TO ANY PARTY
 FOR DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES
 ARISING OUT OF THE USE OF THIS SOFTWARE AND ITS DOCUMENTATION, EVEN IF
 THE UNIVERSITY OF CALIFORNIA HAS BEEN ADVISED OF THE POSSIBILITY OF
 SUCH DAMAGE.

 THE UNIVERSITY OF CALIFORNIA SPECIFICALLY DISCLAIMS ANY WARRANTIES,
 INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE SOFTWARE
 PROVIDED HEREUNDER IS ON AN "AS IS" BASIS, AND THE UNIVERSITY OF
 CALIFORNIA HAS NO OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES,
 ENHANCEMENTS, OR MODIFICATIONS.


 METROPOLIS_COPYRIGHT_VERSION_1
 COPYRIGHTENDKEY


 */

package metropolis.metamodel;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.LineNumberReader;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.StringTokenizer;

// ////////////////////////////////////////////////////////////////////////
// // GenerateVisitor
/**
 * Generate a visitor class and a group of node classes.
 *
 * The following command:
 *
 * <pre>
 *  cd $PTII/ptolemy/lang/java
 *  javac ptolemy.lang.GenerateVisitor NodeTypes.def JavaVisitor TreeNode nodetypes
 * </pre>
 *
 * Will read NodeTypes.def and generate JavaVisitor.java and a nodetypes
 * directory.
 *
 *
 * <p>
 * The syntax of NodeTypes.def is documented in Jeff Tsay's Masters report at
 * http://ptolemy.eecs.berkeley.edu/publications/papers/00/codegen/, below is a
 * brief summary. <menu>
 * <li>
 * <li> cheader: common header
 * <li> vheader: visitor header
 * <li> nheader: nodes
 * <li> iheader: interface that contains node IDS.
 * <li> NamedNode I ITreeNode m NameNode getName m m void setName NameNode name
 * m <br>
 * generate interface NamedNode.java, derived from ITreeNode. it has method
 * getName, returning NameNode. method definition is enclosed by "m" on both
 * sides.
 * <li> I means interface.
 * <li> A means abstract class.
 * <li> C is concrete class.
 * <li> S singleton class, used for types, or an absent tag indicating a missing
 * field, such as a static initializer not given in a declaration.
 * <li> m is method.
 * <li> c is constructor. "c 0 c" passes no arguments to super constructor.
 * (always the first n args are passed).
 * <li> SN singleton class not generated by the parser. Types like null, or
 * {...} for array inits.
 *
 * </menu>
 *
 * @author Jeff Tsay
 * @version $Id: GenerateVisitor.java,v 1.48 2006/10/12 20:31:59 cxh Exp $
 */
public class GenerateVisitor {

    /**
     * Instantiate a GenerateVisitor.
     *
     * @param args
     *            The arguments used to control the GeneratorVisitor. <br>
     *            The first argument is required, and should name a node
     *            definition file. <br>
     *            The second argument is optional, and names visitor class name.
     *            If this argument is not present, then the default visitor
     *            class name is <code>Visitor</code>, and the name of the
     *            file that will be created is <code>Visitor.java</code>.
     *            <br>
     *            The third argument is optional, and it names the base node
     *            name. If this argument is not present, then the default base
     *            node name is <code>TreeNode</code>. <br>
     *            The third argument is optional, and it names node path, which
     *            should be a directory. If this argument is not present, then
     *            the default base node name is <code>.</code>. <br>
     *            For example, to create MetaModelVisitor.java, we run:
     *
     * <pre>
     *   java -classpath $METRO/src
     *                 metropolis.metamodel.GenerateVisitor \
     *                 NodeTypes.def MetaModelVisitor TreeNode nodetypes
     *   @exception IOException If there is a problem reading the node
     *   definition file.
     *
     */
    public GenerateVisitor(String[] args) throws IOException {

        File inputFile = new File(args[0]);

        String visitorOutFileName;
        if (args.length < 2) {
            _visitorClassName = "Visitor";
            visitorOutFileName = "Visitor.java";
        } else {
            _visitorClassName = args[1];
            visitorOutFileName = _visitorClassName + ".java";
        }

        if (args.length < 3) {
            _baseNodeName = "TreeNode";
        } else {
            _baseNodeName = args[2];
        }

        if (args.length < 4) {
            _nodePath = ".";
        } else {
            _nodePath = args[3];
        }

        if (_nodePath.charAt(_nodePath.length() - 1) != File.separatorChar) {
            _nodePath = _nodePath + File.separatorChar;
        }

        File visitorOutFile = new File(visitorOutFileName);

        if (!visitorOutFile.createNewFile()) {
            visitorOutFile.delete();
            visitorOutFile = new File(visitorOutFileName);
            visitorOutFile.createNewFile();
        }

        try {
            _visitorOutFileWriter = new FileWriter(visitorOutFile);
        } catch (FileNotFoundException e) {
            System.err.println("Couldn't open destination file.");
            return;
        }

        try {
            _inputFileReader = new LineNumberReader(new FileReader(inputFile));
        } catch (FileNotFoundException e) {
            System.err.println("Couldn't open input file.");
            return;
        }

        // initialize _lastLine
        _lastLine = _inputFileReader.readLine();

        // get common header for nodes and visitor
        String commonHeader = _readBlock("cheader");

        // get header for visitor
        _visitorHeader = commonHeader + _readBlock("vheader");

        // get header for nodes
        _nodeHeader = commonHeader + _readBlock("nheader");

        // get header for classID's
        _classIDHeader = commonHeader + _readBlock("iheader");
    }

    // /////////////////////////////////////////////////////////////////
    // // public methods ////

    /**
     * Generate the visitor class and the node class files.
     *
     * @exception IOException
     *                If there is a problem reading or writing a file.
     */
    public void generate() throws IOException {

        _visitorOutFileWriter.write(_visitorHeader);
        //_visitorOutFileWriter.write("/**\n" + " * $" + "Id" + "$\n" + " */\n");
        _visitorOutFileWriter
                .write("public class "
                        + _visitorClassName
                        + " implements IVisitor {\n"
                        + "    /** Construct a MetaModelVisitor. */\n"
                        + "    public "
                        + _visitorClassName
                        + "() {\n"
                        + "        this(TM_CHILDREN_FIRST);\n"
                        + "    }\n\n"
                        + "    /** Construct a MetaModelVisitor.\n"
                        + "     *  @param traversalMethod The method used to traverse the\n"
                        + "     *  children, usually one of\n"
                        + "     *  {@link metropolis.metamodel.IVisitor#TM_CHILDREN_FIRST},\n"
                        + "     *  {@link metropolis.metamodel.IVisitor#TM_SELF_FIRST}\n"
                        + "     *  or {@link metropolis.metamodel.IVisitor#TM_CUSTOM}.\n"
                        + "     */\n"
                        + "    public "
                        + _visitorClassName
                        + "(int traversalMethod) {\n"
                        + "        if (traversalMethod > TM_CUSTOM) {\n"
                        + "           throw new RuntimeException(\""
                        + "Illegal traversal method\");\n"
                        + "        }\n"
                        + "        _traversalMethod = traversalMethod;\n"
                        + "    }\n\n"
                        + "    /** Specify the order in visiting the nodes. */\n"
                        + "    public final int traversalMethod() { "
                        + "return _traversalMethod; }\n");

        _readPlacement();

        _readClassInfo();

        _inputFileReader.close();

        Iterator iterator = _typeList.iterator();
        Iterator parentIterator = _parentTypeList.iterator();
        Iterator concreteIterator = _isConcreteList.iterator();
        Iterator singletonIterator = _isSingletonList.iterator();
        Iterator inTreeIterator = _isInTreeList.iterator();
        Iterator interfaceIterator = _isInterfaceList.listIterator();
        Iterator methodListIterator = _methodListList.iterator();
        Iterator implListIterator = _implListList.iterator();
        Iterator javaDocCommentIterator = _javaDocCommentList.iterator();

        while (iterator.hasNext()) {
            String typeName = (String) iterator.next();
            String parentTypeName = (String) parentIterator.next();
            boolean isConcrete = ((Boolean) concreteIterator.next())
                    .booleanValue();
            boolean isSingleton = ((Boolean) singletonIterator.next())
                    .booleanValue();
            boolean isInterface = ((Boolean) interfaceIterator.next())
                    .booleanValue();
            boolean isInTree = ((Boolean) inTreeIterator.next()).booleanValue();

            LinkedList methodList = (LinkedList) methodListIterator.next();
            LinkedList implList = (LinkedList) implListIterator.next();
            String javaDocComment = (String) javaDocCommentIterator.next();

            if (isConcrete) {
                if (isInTree) {
                    _visitorOutFileWriter.write("\n" + "    /** Visit a "
                            + typeName + " node.\n"
                            + "     *  @param node The " + typeName
                            + " to visit.\n"
                            + "     *  @param args The arguments to pass in.\n"
                            + "     *  @return an Object, which is usually "
                            + "a node.\n"
                            + "     *  The return value may be null.\n" +

                            "     */\n" + "    public Object visit" + typeName
                            + "(" + typeName
                            + " node,\n            LinkedList args) {\n"
                            + "        return _defaultVisit(node, args);\n"
                            + "    }\n");
                }

                _idStringList.add(typeName);
            }

            _generateNodeFile(typeName, parentTypeName, isConcrete,
                    isSingleton, isInterface, isInTree, methodList, implList,
                    javaDocComment);

            _generateClassIDFile();
        }

        _visitorOutFileWriter.write("\n"
                + "    /** The default visit method.\n"
                + "     *  @param node The " + _baseNodeName
                + " base type node.\n"
                + "     *  @param args Arguments to pass in.\n"
                + "     *  @return an Object, which is usually a node.\n"
                + "     *  The return value may be null.\n" + "     */\n"
                + "    protected Object _defaultVisit(" + _baseNodeName
                + " node, LinkedList args) {\n" + "        return null;\n"
                + "    }\n" + "\n"
                + "    /** Value is used to determine how the children of\n"
                + "     *  a node are visited.\n" + "     */\n"
                + "    protected final int _traversalMethod;\n" + "}\n");

        _visitorOutFileWriter.close();
    }

    /**
     * Invoke GenerateVisitor with a set of arguments.
     *
     * @param args
     *            See {#GenerateVisitor(String[]).
     * @exception IOException
     *                If there is a problem reading or writing a file.
     */
    public static void main(String[] args) throws IOException {
        if (args.length < 1) {
            System.out.println("Usage : GenerateVisitor TypeNameListFile "
                    + "[VisitorClassName] [BaseNodeName] [node path]");
            return;
        }

        GenerateVisitor genVisitor = new GenerateVisitor(args);

        genVisitor.generate();
    }

    // /////////////////////////////////////////////////////////////////
    // // protected methods ////

    /**
     * Generate a class ID file with the name of NodeClassID.java. The node
     * class ID file contains class ID's for all concrete node types.
     *
     * @exception IOException
     *                If there is a problem creating the file.
     */
    protected void _generateClassIDFile() throws IOException {
        File nodeClassIDFile = new File(_nodePath + "NodeClassID.java");

        if (!nodeClassIDFile.createNewFile()) {
            nodeClassIDFile.delete();
            nodeClassIDFile = new File(_nodePath + "NodeClassID.java");
            nodeClassIDFile.createNewFile();
        }

        FileWriter nodeClassIDFileWriter = new FileWriter(nodeClassIDFile);

        StringBuffer stringBuffer = new StringBuffer();

        stringBuffer.append(_classIDHeader);
        stringBuffer.append("/**\n");
        stringBuffer.append(" * $" + "Id" + "$\n");
        stringBuffer.append(" */\n");

        stringBuffer.append("public interface NodeClassID {\n");

        int count = 0;

        Iterator stringIterator = _idStringList.iterator();

        while (stringIterator.hasNext()) {
            String idString = (String) stringIterator.next();
            ClassField field = new ClassField("int", idString.toUpperCase()
                    + "_ID", "public", Integer.toString(count));

            stringBuffer.append("    /** Class ID for " + idString
                    + " class.\n" + "      * @see " + idString + "\n"
                    + "      */\n" + field.toString() + "\n\n");
            count++;
        }
        stringBuffer.append("}\n");

        nodeClassIDFileWriter.write(stringBuffer.toString());
        nodeClassIDFileWriter.close();
    }

    /**
     * Generate a node file.
     *
     * @param typeName
     *            The type name.
     * @param parentTypeName
     *            The parent type name.
     * @param isConcrete
     *            True if this type is concrete.
     * @param isSingleton
     *            True if this type is a singleton.
     * @param isInterface
     *            True if this type is an interface.
     * @param isInTree
     *            True if this type is in the tree FIXME: ?
     * @param methodList
     *            A list of methods.
     * @param implList
     *            A list of implementers.
     * @param javaDocComment
     *            Th javadoc comment to use. If this parameter is null, then a
     *            default comment is used.
     * @exception IOException
     *                If there is a problem reading or writing a file.
     */
    protected void _generateNodeFile(String typeName, String parentTypeName,
            boolean isConcrete, boolean isSingleton, boolean isInterface,
            boolean isInTree, LinkedList methodList, LinkedList implList,
            String javaDocComment) throws IOException {
        File nodeFile = new File(_nodePath + typeName + ".java");

        if (!nodeFile.createNewFile()) {
            nodeFile.delete();
            nodeFile = new File(_nodePath + typeName + ".java");
            nodeFile.createNewFile();
        }

        FileWriter nodeFileWriter = new FileWriter(nodeFile);

        StringBuffer stringBuffer = new StringBuffer();

        // Append imports - keep them alphabetical
        stringBuffer.append(_nodeHeader);

        boolean addedTreeNodeImport = false;

        if (parentTypeName.equals("ITreeNode")) {
            // We only include the import for ITreeNode if it is necessary,
            // thus decreasing the number of warnings that Eclipse gives about
            // unnecessary imports
            stringBuffer.append("import metropolis.metamodel.ITreeNode;\n");
        }

        boolean concreteClass = isConcrete && !isInterface;

        if (concreteClass && isInTree) {
            // Only include imports that we actually need.
            stringBuffer.append("import metropolis.metamodel.IVisitor;\n"
                    + "import metropolis.metamodel.MetaModelVisitor;\n");
        }

        if (parentTypeName.equals("TreeNode")) {
            // We could include TreeNode in the else clause for ITreeNode,
            // but instead we include this here so as to keep the
            // imports alphabetical so that when we run Eclipse to fix
            // the imports, there is no difference between the order of
            // imports when GenerateVisitor creates them, and when
            // Eclipse fixes the imports.
            //
            // We only include the import for TreeNode if it is necessary,
            // thus decreasing the number of warnings that Eclipse gives about
            // unnecessary imports
            addedTreeNodeImport = true;
            stringBuffer.append("import metropolis.metamodel.TreeNode;\n");
        }

        // FIXME: Metropolis - added to test cacheing
        if ((!isInterface) && (!isSingleton)) {
            if (methodList.size() == 0)
                methodList.add(new MethodSignature("Construct "
                        + _aOrAn(typeName) + typeName + ".\n", "public", "",
                        typeName, new LinkedList(), new LinkedList(), ""));
            else {
                MethodSignature m = (MethodSignature) methodList.getFirst();
                if (!m._name.equals(typeName) || (m._paramTypes.size() != 0)) {
                    methodList.add(new MethodSignature("Construct "
                            + _aOrAn(typeName) + typeName + ".\n", "public",
                            "", typeName, new LinkedList(), new LinkedList(),
                            ""));
                }
            }
        }

        if (concreteClass) {
            String idString = typeName.toUpperCase() + "_ID";

            // add a method to return the class id
            methodList.add(new MethodSignature("Return the classID.\n",
                    "public ", "int", "classID", new LinkedList(),
                    new LinkedList(), "return NodeClassID." + idString + ";"));

            if (isInTree) {
                // add a method that accepts a visitor
                LinkedList acceptMethodArgTypes = new LinkedList();
                acceptMethodArgTypes.addLast("IVisitor");
                acceptMethodArgTypes.addLast("LinkedList");

                LinkedList acceptMethodArgNames = new LinkedList();
                acceptMethodArgNames.addLast("visitor");
                acceptMethodArgNames.addLast("args");

                methodList.add(new MethodSignature(
                        "Accept a visitor at this node.\n", "protected ",
                        "Object", "_acceptHere", acceptMethodArgTypes,
                        acceptMethodArgNames, "return ((" + _visitorClassName
                                + ") visitor).visit" + typeName
                                + "(this, args);"));
            }
        }

        if (isSingleton) {

            // add the instance of the singleton
            ClassField cf = new ClassField(typeName, "instance",
                    "public static final", "new " + typeName + "()",
                    "    /** Instance of this singleton class. */\n");
            methodList.addLast(cf);

            // add the constructor of the singleton
            MethodSignature methodSignature = new MethodSignature(typeName);
            methodList.addLast(methodSignature);

            // add a isSingleton() method
            methodList.add(new MethodSignature(
                    "Return true if this object is a singleton.",
                    "public final", "boolean", "isSingleton", new LinkedList(),
                    new LinkedList(), "return true;"));
        }

        // Go through methods and look for List and TreeNode args
        // that we need to add as imports.
        Iterator methodIterator = methodList.listIterator();

        boolean needListImport = false;
        while (methodIterator.hasNext()) {
            Object o = methodIterator.next();

            if (o instanceof MethodSignature) {
                Iterator paramTypes = ((MethodSignature) o).getParamTypes()
                        .iterator();
                while (paramTypes.hasNext()) {
                    String paramType = (String) paramTypes.next();
                    if (!needListImport && paramType.equals("List")) {
                        needListImport = true;
                    }
                    if (!addedTreeNodeImport && paramType.equals("TreeNode")) {
                        addedTreeNodeImport = true;
                        stringBuffer
                                .append("import metropolis.metamodel.TreeNode;\n");
                    }
                }
            }
        }

        // Import the java.* classes last, with an empty line between
        // the metropolis.* imports. This will match the output of
        // Eclipse's "Fix Imports" facility.

        boolean addedNewLineBeforeJavaImports = false;

        if (concreteClass && isInTree) {
            addedNewLineBeforeJavaImports = true;
            stringBuffer.append("\nimport java.util.LinkedList;\n");
        }

        if (needListImport) {
            if (!addedNewLineBeforeJavaImports) {
                stringBuffer.append("\n");
            }

            stringBuffer.append("import java.util.List;\n");
        }

        if (javaDocComment == null) {
            stringBuffer.append("\n");
            stringBuffer.append("/**\n");
            stringBuffer.append(" * A specific type of node in the AST for ");
            stringBuffer.append("meta-model code.\n");
            stringBuffer.append(" *\n");
            stringBuffer.append(" * $" + "Id" + "$\n");
            stringBuffer.append(" */\n");
        } else {
            stringBuffer.append("\n" + javaDocComment);
            stringBuffer.append("\n");
            stringBuffer.append("/**\n");
            stringBuffer.append(" * $" + "Id" + "$\n");
            stringBuffer.append(" */\n");
        }

        // Append class decl
        stringBuffer.append("public ");

        if (!isConcrete && !isInterface) {
            stringBuffer.append("abstract ");
        } else if (isSingleton) {
            stringBuffer.append("final ");
        }

        stringBuffer.append(isInterface ? "interface " : "class ");
        stringBuffer.append(typeName);

        if (!parentTypeName.equals("<none>")) {
            stringBuffer.append(" extends ");
            stringBuffer.append(parentTypeName);
        }

        Iterator implIterator = implList.listIterator();

        if (implIterator.hasNext()) {
            stringBuffer.append(" implements ");

            do {
                String interfaceName = (String) implIterator.next();

                stringBuffer.append(interfaceName);

                if (implIterator.hasNext()) {
                    stringBuffer.append(", ");
                }
            } while (implIterator.hasNext());
        }

        stringBuffer.append(" {\n");

        // Now do method definitions
        methodIterator = methodList.listIterator();

        while (methodIterator.hasNext()) {
            Object o = methodIterator.next();

            if (o instanceof MethodSignature) {
                stringBuffer.append(o.toString() + "\n");
            }
        }

        // now do fields
        methodIterator = methodList.listIterator();

        while (methodIterator.hasNext()) {
            Object o = methodIterator.next();

            if (o instanceof ClassField) {
                stringBuffer.append(o.toString() + "\n");
            }
        }

        stringBuffer.append("}\n");

        nodeFileWriter.write(stringBuffer.toString());
        nodeFileWriter.close();
    }

    /**
     * Read a block from the node definition input file. A block is text that is
     * surrounded by marker tags of the format
     * <code>&lt;<i>marker</i>&gt; ... &lt;<i>/marker</i>&gt;</code>
     *
     * @param marker
     *            The marker string, for example "vheader".
     * @return The block, if any. If the block is not found, then the empty
     *         string is returned.
     * @exception IOException
     *                If there is a problem reading the node definition file.
     */
    protected String _readBlock(String marker) throws IOException {
        if (_lastLine != null) {
            _lastLine = _lastLine.trim();
        }

        while ((_lastLine != null)
                && (_lastLine.equals("") || _lastLine.startsWith("//"))) {
            _lastLine = _inputFileReader.readLine();

            if (_lastLine != null) {
                _lastLine = _lastLine.trim();
            }
        }

        String beginTag = "<" + marker + ">";
        String endTag = "</" + marker + ">";

        if ((_lastLine == null) || !_lastLine.equals(beginTag)) {
            return "";
        }

        StringBuffer stringBuffer = new StringBuffer();

        boolean endHeader = false;
        do {
            _lastLine = _inputFileReader.readLine();

            endHeader = ((_lastLine == null) || _lastLine.equals(endTag));

            if (!endHeader) {
                stringBuffer.append(_lastLine + "\n");
            }
        } while (!endHeader);

        _lastLine = _inputFileReader.readLine();

        stringBuffer.append('\n');

        return stringBuffer.toString();
    }

    /**
     * Read class information from the node definition file.
     *
     * @exception IOException
     *                If there is a problem reading the node definition file.
     */
    protected void _readClassInfo() throws IOException {
        StringTokenizer stringTokenizer;
        String className;
        String marker;
        StringBuffer javaDocComment = null;

        do {
            if (_lastLine != null && _lastLine.startsWith("/**")) {
                // Start of a javadoc style comment.
                javaDocComment = new StringBuffer();
                do {
                    javaDocComment.append(_lastLine + "\n");
                    _lastLine = _inputFileReader.readLine();
                } while (_lastLine != null && !_lastLine.startsWith(" */"));
                javaDocComment.append(" */\n");
            }

            if ((_lastLine != null) && (_lastLine.length() > 4)
                    && !(_lastLine.startsWith("//"))) {
                stringTokenizer = new StringTokenizer(_lastLine);

                className = stringTokenizer.nextToken();

                System.out.println("Reading class info for : " + className);

                if (javaDocComment != null) {
                    _javaDocCommentList.addLast(javaDocComment.toString());
                } else {
                    _javaDocCommentList.addLast(null);
                }
                javaDocComment = null;

                try {
                    _typeList.addLast(className);
                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : "
                            + _lastLine);
                    return;
                }

                String nextToken = stringTokenizer.nextToken();

                boolean isSingleton;
                boolean isInterface;
                boolean isConcrete;
                try {
                    isSingleton = nextToken.startsWith("S");
                    _isSingletonList.addLast(new Boolean(isSingleton));

                    isConcrete = isSingleton || nextToken.startsWith("C");
                    _isConcreteList.addLast(new Boolean(isConcrete));

                    isInterface = nextToken.startsWith("I");
                    _isInterfaceList.addLast(new Boolean(isInterface));

                    _isInTreeList
                            .addLast(new Boolean(!nextToken.endsWith("N")));

                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : "
                            + _lastLine);
                    return;
                }

                try {
                    nextToken = stringTokenizer.nextToken();
                    _parentTypeList.addLast(nextToken);
                } catch (NullPointerException e) {
                    System.err.println("Not enough parameters in line : "
                            + _lastLine);
                    return;
                }

                LinkedList methodList = new LinkedList();
                LinkedList implList = new LinkedList();

                while (stringTokenizer.hasMoreTokens()) {
                    marker = stringTokenizer.nextToken();
                    char markChar = marker.charAt(0);
                    switch (markChar) {

                    case 'c':
                    case 'm': {
                        MethodSignature methodSignature = new MethodSignature(
                                markChar, stringTokenizer, className,
                                _defaultPlacement, isInterface, isConcrete);
                        methodList.addLast(methodSignature);
                    }
                        break;

                    case 'k': {
                        MethodSignature methodSignature = new MethodSignature(
                                markChar, stringTokenizer, className,
                                _defaultPlacement, isInterface, isConcrete);

                        methodList.addLast(methodSignature);
                        methodList.addAll(methodSignature.accessors());
                    }
                        break;

                    case 'i': // add a class name to the implements list
                    {
                        boolean isName;
                        do {
                            nextToken = stringTokenizer.nextToken();

                            isName = ((nextToken != null) && !nextToken
                                    .equals("i"));
                            if (isName) {
                                implList.addLast(nextToken);
                            }
                        } while (isName);
                    }
                        break;

                    default:
                        throw new RuntimeException("Unrecognized marker: '"
                                + marker + "' in '" + _lastLine + "'");
                    }
                }

                _methodListList.addLast(methodList);
                _implListList.addLast(implList);
            }
            _lastLine = _inputFileReader.readLine();
        } while (_lastLine != null);
    }

    /**
     * Read the default placement value. The "mplace" directive in the node
     * definition file determines the placement.
     *
     * @exception IOException
     *                If there is a problem reading the node definition file.
     */
    protected void _readPlacement() throws IOException {
        _lastLine = _inputFileReader.readLine();

        if (_lastLine.startsWith("mplace")) {
            _defaultPlacement = _lastLine.charAt(7);
            _lastLine = _inputFileReader.readLine();
        }
    }

    // /////////////////////////////////////////////////////////////////
    // // protected variables ////

    /**
     * The default placement. The default value is the character 'l'
     */
    protected char _defaultPlacement = 'l';

    /** The FileWriter which writes out the visitor .java file. */
    protected FileWriter _visitorOutFileWriter;

    /** The LineNumberReader associated with the input definition file. */
    protected LineNumberReader _inputFileReader;

    /** A list of types. */
    protected LinkedList _typeList = new LinkedList();

    /** A list of parent types. */
    protected LinkedList _parentTypeList = new LinkedList();

    /** A list of concrete types. */
    protected LinkedList _isConcreteList = new LinkedList();

    /** A list of singleton types. */
    protected LinkedList _isSingletonList = new LinkedList();

    /** A list of interfaces. */
    protected LinkedList _isInterfaceList = new LinkedList();

    /** A list of types that are in tree. */
    protected LinkedList _isInTreeList = new LinkedList();

    /** A list of javadoc comments. */
    protected LinkedList _javaDocCommentList = new LinkedList();

    /** A list of lists of methods. */
    protected LinkedList _methodListList = new LinkedList();

    /** A list of lists of implementors. */
    protected LinkedList _implListList = new LinkedList();

    /** A list of idStrings. */
    protected LinkedList _idStringList = new LinkedList();

    /** The name of the visitor class, defaults to "Visitor". */
    protected String _visitorClassName;

    /** The name of the base node, defaults to "TreeNode". */
    protected String _baseNodeName;

    /**
     * The "nheader" section of the node definition file that defines the node
     * header.
     */
    protected String _nodeHeader;

    /**
     * The "vheader" section of the node definition file that defines the
     * visitor header.
     */
    protected String _visitorHeader;

    /**
     * The "iheader" section of the node definition file that defines the class
     * ID header.
     */
    protected String _classIDHeader;

    /**
     * The path to the directory where files should be generated, defaults to
     * ".", meaning the current directory.
     */
    protected String _nodePath;

    /** The last line that was read. */
    protected String _lastLine;

    // /////////////////////////////////////////////////////////////////
    // // inner class ////

    /** A Method comment. */
    public static class MethodComment {
        /**
         * Create a method comment.
         *
         * @param description
         *            A description of the method. The first sentence should be
         *            a complete sentence ending in a period that describes the
         *            method and include a trailing newline.
         */
        public MethodComment(String description) {
            this(description, "", "");
        }

        /**
         * Create a method comment.
         *
         * @param description
         *            A description of the method. The first sentence should be
         *            a complete sentence ending in a period that describes the
         *            method and include a trailing newline.
         * @param paramTypes
         *            A list of Strings naming the types of the parameters.
         * @param paramNames
         *            A list of Strings naming the names the parameters.
         * @param returns
         *            Javadoc text describing what is returned. If nothing is
         *            returned, then use the empty string "".
         */
        public MethodComment(String description, LinkedList paramTypes,
                LinkedList paramNames, String returns) {
            _description = description;

            StringBuffer paramsBuffer = new StringBuffer();

            Iterator paramTypesIterator = paramTypes.iterator();
            Iterator paramNamesIterator = paramNames.iterator();
            while (paramNamesIterator.hasNext()) {
                String paramName = (String) paramNamesIterator.next();
                String paramType = (String) paramTypesIterator.next();
                paramsBuffer.append(_IDENT + " *  @param " + paramName
                        + " The " + paramType + ".\n");
            }
            _params = paramsBuffer.toString();

            // Don't update returns if it is mostly empty.
            if (!returns.equals("") && !returns.equals(".\n")
                    && !returns.equals("void.\n")) {
                _returns = _IDENT + " *  @return " + returns;
            }
        }

        /**
         * Create a method comment.
         *
         * @param description
         *            A description of the method. The first sentence should be
         *            a complete sentence ending in a period that describes the
         *            method and include a trailing newline
         * @param params
         *            Javadoc text describing one or more parameters. If there
         *            are no parameters, then use the empty string "".
         * @param returns
         *            Javadoc text describing what is returned. If nothing is
         *            returned, then use the empty string "".
         */
        public MethodComment(String description, String params, String returns) {
            _description = description;
            _params = params;
            _returns = returns;
        }

        /**
         * Return the method comment.
         *
         * @return The method comment.
         */
        public String toString() {
            StringBuffer comment = new StringBuffer("/** " + _description);

            if (!_params.equals("")) {
                comment.append(_params);
            }
            if (!_returns.equals("")) {
                comment.append(_returns);
            }
            if (!_sees.equals("")) {
                comment.append(_sees);
            }

            comment.append(_IDENT + " */\n");
            return comment.toString();
        }

        // Note that &#64; is an html code for @. We need to hide the
        // @ from javadoc.

        /**
         * Update the contents of the &#64;see tag. If the name starts with
         * "get", we had a tag pointing to the setter. If the name starts with
         * "set", we had a tag pointing to the getter.
         *
         * @param returnType
         *            The return type.
         * @param name
         *            The name.
         */
        public void updateSees(String returnType, String name) {
            if (name.startsWith("get")) {
                _sees = _IDENT + " *  @see #set" + name.substring(3) + "("
                        + returnType.trim() + ")\n";
            } else if (name.startsWith("set")) {
                _sees = _IDENT + " *  @see #get" + name.substring(3) + "()\n";
            }
        }

        // The description.
        private String _description = "";

        // The @param value javadoc text.
        private String _params = "";

        // The @return value javadoc text.
        // Named _returns instead of _return so we can use returns as a
        // method param because return is a keyword.
        private String _returns = "";

        // The @sees javadoc text, if any.
        private String _sees = "";
    }

    /** The signature of a Method. */
    public static class MethodSignature {

        /** Instantiate a MethodSignature. */
        public MethodSignature() {
        }

        /**
         * Instantiate a MethodSignature.
         *
         * @param modifiers
         *            The modifiers.
         * @param returnType
         *            The return type.
         * @param name
         *            The name.
         * @param paramTypes
         *            The parameter types. (FIXME: what are the element types)
         * @param paramNames
         *            The parameter names. (FIXME: what are the element types)
         * @param methodBody
         *            The method body
         */
        public MethodSignature(String modifiers, String returnType,
                String name, LinkedList paramTypes, LinkedList paramNames,
                String methodBody) {
            // FIXME: need a better description in the comment
            MethodComment comment = new MethodComment(name + ".\n", paramTypes,
                    paramNames, returnType + ".\n");
            _comment = comment.toString();
            _modifiers = modifiers;
            _returnType = returnType;
            _name = name;
            _paramTypes = paramTypes;
            _paramNames = paramNames;
            _methodBody = methodBody;
        }

        /**
         * Instantiate a MethodSignature.
         *
         * @param commentDescription
         *            The method comment description. Do not include
         *            &#064;param or &#064;return tags, they are added
         *            automatically.
         * @param modifiers
         *            The modifiers.
         * @param returnType
         *            The return type.
         * @param name
         *            The name.
         * @param paramTypes
         *            A list of Strings naming the parameter types.
         * @param paramNames
         *            A list of Strings naming parameter names.
         * @param methodBody
         *            The method body.
         */
        public MethodSignature(String commentDescription, String modifiers,
                String returnType, String name, LinkedList paramTypes,
                LinkedList paramNames, String methodBody) {

            MethodComment comment = new MethodComment(commentDescription,
                    paramTypes, paramNames, returnType + ".\n");
            _comment = comment.toString();
            _modifiers = modifiers;
            _returnType = returnType;
            _name = name;
            _paramTypes = paramTypes;
            _paramNames = paramNames;
            _methodBody = methodBody;
        }

        /**
         * Instantiate the method signature of a singleton constructor.
         *
         * @param className
         *            The name of the class.
         */
        public MethodSignature(String className) {
            _comment = "/** Construct " + _aOrAn(className) + className + ".\n"
                    + _IDENT + " *  This class is a singleton, thus this "
                    + "constructor is private.\n" + _IDENT + " */\n";

            _modifiers = "private";
            _name = className;
            _construct = true;
            _isConcrete = true;
        }

        /**
         * Instantiate the method signature of a constructor or method.
         *
         * @param signatureType
         *            The signature type:
         *            <dl>
         *            <dt><code>c</code>
         *            <dd>Constructor
         *            <dt><code>k</code>
         *            <dd>Default Constructor
         *            <dt><code>m</code>
         *            <dd>Method
         *            </dl>
         * @param stringToken
         *            a StringTokenizer object.
         * @param className
         *            The name of the class.
         * @param defaultPlacement
         *            The placement 'l'
         * @param isInterface
         *            True if the method is in an interface.
         * @param isConcrete
         *            True if the method is concrete.
         */
        public MethodSignature(char signatureType, StringTokenizer stringToken,
                String className, char defaultPlacement, boolean isInterface,
                boolean isConcrete) {

            _isInterface = isInterface;
            _isConcrete = isConcrete;

            _defConstruct = (signatureType == 'k');
            _construct = (signatureType == 'c') || _defConstruct;

            _modifiers = "public";

            if (_construct) { // constructor
                _name = className;
                _returnType = "";

                _superParameters = Integer.parseInt(stringToken.nextToken());

            } else if (signatureType == 'm') { // method
                _superParameters = 0;

                if (!isInterface)
                    _modifiers += " final";

                _returnType = stringToken.nextToken() + " ";

                _name = stringToken.nextToken();
            } else {
                throw new RuntimeException("Invalid token for "
                        + "MethodSignature : " + signatureType);
            }

            String s = stringToken.nextToken();

            while (!(s.equals("c") || s.equals("m") || s.equals("k"))) {
                if (s.charAt(0) == '{') {
                    // explicit placement, don't check
                    _variablePlacements.addLast(new Character(s.charAt(1)));
                    s = s.substring(3);
                } else {

                    if ((defaultPlacement == 'l') && _isJavaType(s)) {
                        // make it a member if it's a Java type and we
                        // default to put it in a list
                        _variablePlacements.addLast(new Character('m'));
                    } else {
                        if (defaultPlacement == 'l') {
                            _childListSize++;
                        }

                        _variablePlacements.addLast(new Character(
                                defaultPlacement));
                    }
                }

                if (s.equals("[")) { // super constructor argument
                    StringBuffer stringBuffer = new StringBuffer();
                    boolean isInit;

                    s = stringToken.nextToken();

                    stringBuffer.append(s);

                    do {
                        s = stringToken.nextToken();

                        isInit = !s.equals("]");

                        if (isInit) {
                            stringBuffer.append(' ');
                            stringBuffer.append(s);
                        }
                    } while (isInit);

                    _superArgs.addLast(stringBuffer.toString());

                    _paramTypes.addLast("omitted");
                    _paramNames.addLast("omitted");

                } else {

                    _paramTypes.addLast(s);

                    String paramName = stringToken.nextToken();

                    _paramNames.addLast(paramName);
                    _superArgs.addLast(paramName);
                }

                s = stringToken.nextToken();
            }
            // Add a comment.
            MethodComment comment = null;
            if (_construct) { // constructor
                comment = new MethodComment("Construct " + _aOrAn(className)
                        + className + ".\n", _paramTypes, _paramNames, "");
            } else {
                comment = new MethodComment(_name + ".\n", _paramTypes,
                        _paramNames, _returnType.trim() + ".\n");
            }

            // If the method name starts with get or set, add to sees
            comment.updateSees(_returnType, _name);

            _comment = comment.toString();
        }

        /**
         * A getter or a setter method for a child in the list. The childIndex
         * parameter is necessary to differentiate this constructor from the
         * following constructor.
         *
         * @param returnType
         *            The return type.
         * @param name
         *            The name.
         * @param childIndex
         *            The childIndex.
         * @param setter
         *            True if this is a setter method.
         */
        public MethodSignature(String returnType, String name, int childIndex,
                boolean setter) {
            _modifiers = "public final";

            Character firstLetter = new Character(Character.toUpperCase(name
                    .charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            if (setter) {
                _comment = "/** Set the " + partName + ".\n" + _IDENT
                        + " *  @param " + name + " the " + partName + "\n"
                        + _IDENT + " *  @see #get" + partName + "()\n" + _IDENT
                        + " */\n";

                _returnType = "void";
                _name = "set" + partName;

                _paramTypes.addLast(returnType);
                _paramNames.addLast(name);

                _methodBody = "_childList.set(CHILD_INDEX_"
                        + name.toUpperCase() + ", " + name + ");";

            } else {
                _comment = "/** Return the " + partName + ".\n" + _IDENT
                        + " *  @return true the " + partName + "\n" + _IDENT
                        + " *  @see #set" + partName + "(" + returnType + ")\n"
                        + _IDENT + " */\n";

                _returnType = returnType;
                _name = "get" + partName;

                _methodBody = "return (" + _returnType
                        + ") _childList.get(CHILD_INDEX_" + name.toUpperCase()
                        + ");";
            }
        }

        /**
         * A getter or a setter method for data not in the list.
         *
         * @param returnType
         *            The return type.
         * @param name
         *            The name.
         * @param setter
         *            True if this is a setter method.
         */
        public MethodSignature(String returnType, String name, boolean setter) {
            _modifiers = "public final";

            Character firstLetter = new Character(Character.toUpperCase(name
                    .charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            if (setter) {
                _comment = "/** Set the " + partName + ".\n" + _IDENT
                        + " *  @param " + name + " the " + partName + "\n"
                        + _IDENT + " *  @see #get" + partName + "()\n" + _IDENT
                        + " */\n";

                _returnType = "void";
                _name = "set" + partName;

                _paramTypes.addLast(returnType);
                _paramNames.addLast(name);

                _methodBody = "_" + name + " = " + name + ";";
            } else {
                _comment = "/** Return the " + partName + ".\n" + _IDENT
                        + " *  @return true the " + partName + "\n" + _IDENT
                        + " *  @see #set" + partName + "(" + returnType + ")\n"
                        + _IDENT + " */\n";

                _returnType = returnType;
                _name = "get" + partName;

                _methodBody = "return _" + name + ";";
            }
        }

        /**
         * A hasX() method that returns true.
         *
         * @param name
         *            The name of the method.
         * @param dummy
         *            Ignored, used to differentiate this constructor from
         *            MethodSignature(String).
         */
        public MethodSignature(String name, int dummy) {
            _comment = "/** Return true if the object has a " + name + ".\n"
                    + _IDENT + "    @return true if the object has a " + name
                    + "\n" + _IDENT + " */\n";

            _modifiers = "public final";

            Character firstLetter = new Character(Character.toUpperCase(name
                    .charAt(0)));

            String partName = firstLetter.toString() + name.substring(1);

            _name = "has" + partName;
            _returnType = "boolean";
            _methodBody = "return true;";
        }

        /**
         * Return the parameter types.
         *
         * @return The parameter types
         */
        public LinkedList getParamTypes() {
            return _paramTypes;
        }

        /**
         * Return the method body.
         *
         * @return the method body.
         */
        public String methodBody() {

            if (_methodBody != null) {
                return _IDENT + _IDENT + _methodBody;
            }

            if (_construct) {

                StringBuffer stringBuffer = new StringBuffer();

                if (_superParameters > 0) {

                    Iterator argsIterator = _superArgs.listIterator();

                    stringBuffer.append(_IDENT + _IDENT);
                    stringBuffer.append("super(");

                    for (int i = 0; i < _superParameters; i++) {
                        stringBuffer.append((String) argsIterator.next());

                        if (i < (_superParameters - 1)) {
                            stringBuffer.append(", ");
                        }
                    }

                    stringBuffer.append(");\n");
                }

                if (_defConstruct) {

                    Iterator typeIterator = _paramTypes.listIterator();
                    Iterator nameIterator = _paramNames.listIterator();
                    Iterator variablePlaceIterator = _variablePlacements
                            .listIterator();

                    int variableCount = 0;

                    do {
                        // Skip one element.
                        /* String typeStr = (String)*/typeIterator.next();
                        String nameStr = (String) nameIterator.next();
                        char placement = ((Character) variablePlaceIterator
                                .next()).charValue();

                        if (variableCount >= _superParameters) {

                            stringBuffer.append(_IDENT);
                            stringBuffer.append(_IDENT);

                            switch (placement) {

                            case 'l':
                                stringBuffer.append("_childList.add(" + nameStr
                                        + ");");
                                break;

                            case 'm':
                            case 'h':
                                stringBuffer.append("_" + nameStr + " = "
                                        + nameStr + ";");
                                break;

                            // case 'p':
                            // stringBuffer.append("setProperty(" + nameStr
                            // + ", "
                            // + _wrapPrimitive(typeStr, nameStr)
                            // + ");");
                            // break;

                            case 'n':
                                // do nothing
                                break;

                            default:
                                throw new RuntimeException(
                                        "unknown variable placement '"
                                                + placement + "'");
                            }

                            if (typeIterator.hasNext()) {
                                stringBuffer.append('\n');
                            }
                        }

                        variableCount++;
                    } while (typeIterator.hasNext());
                }

                if (_isConcrete) {
                    stringBuffer.append("\n" + _IDENT + _IDENT
                            + "_childList.trimToSize();");
                }

                return stringBuffer.toString();
            } // if _construct

            // this is method

            if (_returnType.equals("void") || _returnType.equals("")) {
                return "";
            }

            if (_returnType.equals("long")) {
                return _IDENT + _IDENT + "return 0L;";
            }

            if (_returnType.equals("int") || _returnType.equals("short")
                    || _returnType.equals("byte")) {
                return _IDENT + _IDENT + "return 0;";
            }

            if (_returnType.equals("char")) {
                return _IDENT + _IDENT + "return '\\0';";
            }

            if (_returnType.equals("float")) {
                return _IDENT + _IDENT + "return 0.0f;";
            }

            if (_returnType.equals("double")) {
                return _IDENT + _IDENT + "return 0.0d";
            }

            if (_returnType.equals("boolean")) {
                return _IDENT + _IDENT + "return false";
            }

            return _IDENT + _IDENT + "return null;";
        }

        /**
         * Return a string representation of this object.
         *
         * @return a string representation.
         */
        public String toString() {
            StringBuffer stringBuffer = new StringBuffer(_IDENT);

            if (!_comment.equals("")) {
                stringBuffer.append(_comment + _IDENT);
            }
            if (!_modifiers.equals("")) {
                stringBuffer.append(_modifiers + " ");
            }

            if (!_returnType.equals("")) {
                stringBuffer.append(_returnType + " ");
            }

            stringBuffer.append(_name + "(");

            Iterator typeIterator = _paramTypes.listIterator();
            Iterator nameIterator = _paramNames.listIterator();

            int paramCount = 0;
            while (typeIterator.hasNext()) {

                String typeName = (String) typeIterator.next();
                String paramName = (String) nameIterator.next();

                if (!typeName.equals("omitted")) {
                    if (paramCount > 0) {
                        stringBuffer.append(", ");
                    }
                    paramCount++;

                    stringBuffer.append(typeName);
                    stringBuffer.append(' ');
                    stringBuffer.append(paramName);
                }
            }

            stringBuffer.append(')');

            if (_isInterface) {
                stringBuffer.append(";\n");
            } else {
                stringBuffer.append(" {\n" + methodBody() + "\n" + _IDENT
                        + "}\n");
            }

            return stringBuffer.toString();
        }

        /**
         * Return a linked list containing the accessors.
         *
         * @return The accessors.
         */
        public LinkedList accessors() {
            LinkedList returnValue = new LinkedList();

            int variableCount = 0;
            int childIndex = 0;

            Iterator typeIterator = _paramTypes.listIterator();
            Iterator nameIterator = _paramNames.listIterator();
            Iterator variablePlaceIterator = _variablePlacements.listIterator();

            while (typeIterator.hasNext()) {

                String typeStr = (String) typeIterator.next();
                String nameStr = (String) nameIterator.next();
                char placement = ((Character) variablePlaceIterator.next())
                        .charValue();

                if (variableCount >= _superParameters) {

                    switch (placement) {

                    case 'l':
                        // getter
                        returnValue.addLast(new MethodSignature(typeStr,
                                nameStr, childIndex, false));

                        // setter
                        returnValue.addLast(new MethodSignature(typeStr,
                                nameStr, childIndex, true));

                        // getter index
                        returnValue
                                .addLast(new ClassField(
                                        "int",
                                        "CHILD_INDEX_" + nameStr.toUpperCase(),
                                        "public static final",
                                        Integer.toString(childIndex),
                                        "    /** Index of the "
                                                + nameStr
                                                + " field in the _childList.\n"
                                                + "      * @see metropolis.metamodel.TreeNode#_childList\n"
                                                + "      */\n"));
                        break;

                    case 'h': // member with hasX()
                        returnValue.addLast(new MethodSignature(nameStr, -1));
                        // no break;

                    case 'm': // member
                        returnValue.addLast(new ClassField(typeStr, nameStr));

                        // getter
                        returnValue.addLast(new MethodSignature(typeStr,
                                nameStr, false));

                        // setter
                        returnValue.addLast(new MethodSignature(typeStr,
                                nameStr, true));
                        break;

                    case 'n':
                        // do nothing
                        break;

                    case 'p': // property
                        // do nothing : data is accessed through
                        // PropertyMap methods
                        break;

                    default:
                        throw new RuntimeException("unknown variable placement");

                    }
                }

                if (placement == 'l') {
                    childIndex++;
                }

                variableCount++;
            }

            return returnValue;
        }

        // protected String _wrapPrimitive(String typeStr, String nameStr) {
        // String wrapper = null;
        //
        // if (typeStr.startsWith("int")) {
        // wrapper = "Integer";
        // } else if (typeStr.startsWith("char")) {
        // wrapper = "Character";
        // } else if (typeStr.startsWith("long")) {
        // wrapper = "Long";
        // } else if (typeStr.startsWith("byte")) {
        // wrapper = "Byte";
        // } else if (typeStr.startsWith("float")) {
        // wrapper = "Float";
        // } else if (typeStr.startsWith("double")) {
        // wrapper = "Double";
        // } else if (typeStr.startsWith("boolean")) {
        // wrapper = "Boolean";
        // }
        //
        // if (wrapper != null) {
        // return "new " + wrapper + "(" + nameStr + ")";
        // } else {
        // return nameStr;
        // }
        // }

        /** The method comment. */
        protected String _comment = "";

        /** The modifiers, defaults to "public". */
        protected String _modifiers = "public ";

        /** The return type, defaults to "". */
        protected String _returnType = "";

        /** The name. */
        protected String _name;

        /** A list of parameter types. */
        protected LinkedList _paramTypes = new LinkedList();

        /** A list of parameter names. */
        protected LinkedList _paramNames = new LinkedList();

        /** A list of variable placements. */
        protected LinkedList _variablePlacements = new LinkedList();

        /** A list of arguments in the super class(?). */
        protected LinkedList _superArgs = new LinkedList();

        /**
         * The size of the child list. Not currently used.
         */
        protected int _childListSize = 0;

        /** The number of parameters in the super class. */
        protected int _superParameters = 0;

        /** The method body. */
        protected String _methodBody = null;

        /**
         * True if a constructor should be generated. Default value is false.
         */
        protected boolean _construct = false;

        /**
         * True if the class is an interface and no method bodies should be
         * generated. Default value is false.
         */
        protected boolean _isInterface = false;

        /**
         * True if we should create a default constructor. Default value is
         * false.
         */
        protected boolean _defConstruct = false;

        /** True if this is a member of a concrete class. */
        protected boolean _isConcrete = false;
    }

    /** A class field. */
    public static class ClassField {
        /**
         * Instantiate a class field.
         *
         * @param type
         *            The type.
         * @param name
         *            The name.
         * @param modifiers
         *            The modifiers, such as "protected".
         * @param init
         *            The initial values.
         */
        public ClassField(String type, String name, String modifiers,
                String init) {
            this(type, name, modifiers, init, null);
        }

        /**
         * Instantiate a class field.
         *
         * @param type
         *            The type.
         * @param name
         *            The name.
         * @param modifiers
         *            The modifiers, such as "protected".
         * @param init
         *            The initial values.
         * @param javaDoc
         *            The javadoc comment, if any. If this parameter is null,
         *            then there is no javadoc comment.
         */
        public ClassField(String type, String name, String modifiers,
                String init, String javaDoc) {
            _type = type;
            _name = name;
            _modifiers = modifiers;
            _init = init;
            _javaDoc = javaDoc;
        }

        /**
         * Instantiate a protected class field.
         *
         * @param type
         *            The type.
         * @param name
         *            The name.
         */
        public ClassField(String type, String name) {
            this(type, name, "protected", null, _IDENT + "/** " + name
                    + " of type " + type + ". */\n");
        }

        /**
         * Return a string representation of this object.
         *
         * @return a string representation.
         */
        public String toString() {
            StringBuffer stringBuffer = new StringBuffer();
            if (_javaDoc != null) {
                stringBuffer.append("\n" + _javaDoc);
            }
            stringBuffer.append(_IDENT);
            stringBuffer.append(_modifiers);
            stringBuffer.append(' ');
            stringBuffer.append(_type);
            stringBuffer.append(' ');

            if (!_modifiers.startsWith("public")) {
                stringBuffer.append(" _");
            }

            stringBuffer.append(_name);

            if (_init != null) {
                stringBuffer.append(" = " + _init);
            }

            stringBuffer.append(';');
            return stringBuffer.toString();
        }

        /** The type. */
        String _type;

        /** The name. */
        String _name;

        /** The modifiers, for example, "protected". */
        String _modifiers;

        /** The initial value. */
        String _init;

        /** The javadoc comment, if any. */
        String _javaDoc;
    }

    // /////////////////////////////////////////////////////////////////
    // // private methods ////

    // Return "a " or "an " depending on if name starts with a vowel.
    private static final String _aOrAn(String name) {
        if (name.substring(0, 1).matches("[aeiouAEIOU]")) {
            return "an ";
        }
        return "a ";
    }

    private static final boolean _isPrimitiveType(String s) {
        return (s.startsWith("int") || s.startsWith("char")
                || s.startsWith("long") || s.startsWith("byte")
                || s.startsWith("float") || s.startsWith("double") || s
                .startsWith("boolean"));
    }

    private static final boolean _isJavaType(String s) {
        return (_isPrimitiveType(s) || s.startsWith("String"));
    }

    // /////////////////////////////////////////////////////////////////
    // // private variables ////

    private static final String _IDENT = "    ";
}
