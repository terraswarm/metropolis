$Id: README.txt,v 1.6 2004/05/18 16:25:15 cxh Exp $

PRODUCER CONSUMER EXAMPLE
-------------------------------------------------------------
Demo #1

This is a simple producer consumer systems.

Compile by typing 

make 

Example can be run by typing:

./run.x

after compiling.


APPLICATIONS
--------------------------------------------------------------

Demo #2

This example (even if it is a small example) is used to test two
things: rate and priority, de-synchronization.

Edit ProdConsScheduled.mmm and comment the
de-synchronization statement labeled with number 16:

desynchNetlist(); /*16*/ 

becomes 
 
//desynchNetlist(); /*16*/


The producer has a rate and priority equal to 1 as can be seen at
lines 4 and 5. Build the system and run it:

>make
>run.x

The output that you will observe look like the following:
              SystemC 2.0 --- Sep  4 2003 15:59:37
        Copyright (c) 1996-2004 by all Contributors
                    ALL RIGHTS RESERVED
Set execution order of processes
Begin setting up connections
- processes to media
- media to media
- processes to statemedia
- media to statemedia
- quantities to statemedia
- quantities to quantities
- statemedia to quantities
Producer is executing
Consumer is executing
Now Scheduling Process id: 0
Now Scheduling Process id: 1
Producer is executing
Consumer is executing
Now Scheduling Process id: 0
Now Scheduling Process id: 1
Producer is executing
Consumer is executing
Now Scheduling Process id: 0
Now Scheduling Process id: 1

"Producer is executing" and "Consumer is executing" are generated by
producer and consumer process but they are not interesting at this
moment. 
"Now Scheduling Process id: x" is generated by the main scheduler. It
means that at every cycle both of them are scheduled to be executed
once.


Demo #3
Now you can try different numbers for rate and priority to see the
impact on the scheduling. For instance try to change:

Producer p = new Producer( "P" , 1 , 1);

to 

Producer p = new Producer( "P" , 5 , 1);

Then 

>make clean
>make
>run.x

The output will look like the following:


you may observe that the producer will be
executed 5 more times than the consumer but their interleaving is not
fixed because producer and consumer priorities are equal.


Demo #4

Try now to set 5,2 as last two parameters of the producer (always in
ProdConsScheduled.mmm). Now the producer is executed 5 times the
consumer but the order is always the same. In particular, within a
round, the producer is executed always before the consumer (because
its priority is higher).

Demo #5

Now reset the parameters to 1,1 for both producer and consumer
(you may have tried many combinations at this point, I bet). The
semantic now is the same as Moore finite state machines.
Now uncomment the desynch statement at the end of the prodcons
constructor. 
The result is that you will not see the usual print-out "Now
scheduling...." but you will see only: 
"Producer is executing"
"Consumer is executing"

This is because the former is generate by the quantity manager. But
now the netlist is asynchronous and processes don't make requests to
the quantity manager anymore. 






